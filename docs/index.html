<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Down and Dirty with Semantic Set-theoretic
Types (a tutorial) v0.4</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="autobib.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Down and Dirty with Semantic Set-<wbr></wbr>theoretic
Types (a tutorial) v0.4</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Introduction%29" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._sec~3aoverview%29" class="tocviewlink" data-pltdoc="x">Set-<wbr></wbr>theoretic Types:<span class="mywbr"> &nbsp;</span> An Overview</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._sec~3arep%29" class="tocviewlink" data-pltdoc="x">Set-<wbr></wbr>theoretic Type Representation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Implementing_.Semantic_.Subtyping%29" class="tocviewlink" data-pltdoc="x">Implementing Semantic Subtyping</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Other_.Key_.Type-level_.Functions%29" class="tocviewlink" data-pltdoc="x">Other Key Type-<wbr></wbr>level Functions</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.Strategies_for_.Testing%29" class="tocviewlink" data-pltdoc="x">Strategies for Testing</a></td></tr><tr><td align="right"></td><td><a href="#%28part._doc-bibliography%29" class="tocviewlink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Down_and_.Dirty_with_.Semantic_.Set-theoretic_.Types__a_tutorial__v0_4%29" class="tocsubseclink" data-pltdoc="x">Down and Dirty with Semantic Set-<wbr></wbr>theoretic
Types (a tutorial) v0.4</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Introduction%29" class="tocsubseclink" data-pltdoc="x">Introduction</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Prerequisites%29" class="tocsubseclink" data-pltdoc="x">Prerequisites</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Example_.Grammar_and_.Function_.Definitions%29" class="tocsubseclink" data-pltdoc="x">Example Grammar and Function Definitions</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._sec~3aoverview%29" class="tocsubseclink" data-pltdoc="x">Set-<wbr></wbr>theoretic Types:<span class="mywbr"> &nbsp;</span> An Overview</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Subtyping%29" class="tocsubseclink" data-pltdoc="x">Subtyping</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._sec~3asemantic-subtyping%29" class="tocsubseclink" data-pltdoc="x">Semantic Subtyping</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._sec~3anorm-forms%29" class="tocsubseclink" data-pltdoc="x">Deciding Inhabitation, Normal Forms</a></td></tr><tr><td><span class="tocsublinknumber">2.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Types_in_.Disjunctive_.Normal_.Form%29" class="tocsubseclink" data-pltdoc="x">Types in Disjunctive Normal Form</a></td></tr><tr><td><span class="tocsublinknumber">2.3.2<tt>&nbsp;</tt></span><a href="#%28part._sec~3apartitioning-types%29" class="tocsubseclink" data-pltdoc="x">Partitioning Types</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._sec~3arep%29" class="tocsubseclink" data-pltdoc="x">Set-<wbr></wbr>theoretic Type Representation</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Types_as_.Data_.Structures%29" class="tocsubseclink" data-pltdoc="x">Types as Data Structures</a></td></tr><tr><td><span class="tocsublinknumber">3.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Top_and_.Bottom_.Type_.Representation%29" class="tocsubseclink" data-pltdoc="x">Top and Bottom Type Representation</a></td></tr><tr><td><span class="tocsublinknumber">3.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Type_.Operations%29" class="tocsubseclink" data-pltdoc="x">Type Operations</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._sec~3abase-type-rep%29" class="tocsubseclink" data-pltdoc="x">Base DNF Representation</a></td></tr><tr><td><span class="tocsublinknumber">3.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Base_.D.N.F_.Operations%29" class="tocsubseclink" data-pltdoc="x">Base DNF Operations</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._sec~3abdd-rep%29" class="tocsubseclink" data-pltdoc="x">Product and Function DNFs</a></td></tr><tr><td><span class="tocsublinknumber">3.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Binary_.Decision_.Diagrams%29" class="tocsubseclink" data-pltdoc="x">Binary Decision Diagrams</a></td></tr><tr><td><span class="tocsublinknumber">3.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Types_as_.B.D.Ds_%29" class="tocsubseclink" data-pltdoc="x">Types as BDDs?</a></td></tr><tr><td><span class="tocsublinknumber">3.3.3<tt>&nbsp;</tt></span><a href="#%28part._sec~3atypes-as-lazy-bdds%29" class="tocsubseclink" data-pltdoc="x">Types as Lazy BDDs!</a></td></tr><tr><td><span class="tocsublinknumber">3.3.4<tt>&nbsp;</tt></span><a href="#%28part._.Lazy_.B.D.D_.Operations%29" class="tocsubseclink" data-pltdoc="x">Lazy BDD Operations</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._.Parsing_and_.Example_.Types%29" class="tocsubseclink" data-pltdoc="x">Parsing and Example Types</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_.Semantic_.Subtyping%29" class="tocsubseclink" data-pltdoc="x">Implementing Semantic Subtyping</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Deciding_.Type_.Inhabitation%29" class="tocsubseclink" data-pltdoc="x">Deciding Type Inhabitation</a></td></tr><tr><td><span class="tocsublinknumber">4.1.1<tt>&nbsp;</tt></span><a href="#%28part._sec~3aprod-inhabitation%29" class="tocsubseclink" data-pltdoc="x">Product Type Inhabitation</a></td></tr><tr><td><span class="tocsublinknumber">4.1.2<tt>&nbsp;</tt></span><a href="#%28part._sec~3aarrow-inhabitation%29" class="tocsubseclink" data-pltdoc="x">Function Type Inhabitation</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Other_.Key_.Type-level_.Functions%29" class="tocsubseclink" data-pltdoc="x">Other Key Type-<wbr></wbr>level Functions</a></td></tr><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._.Product_.Projection%29" class="tocsubseclink" data-pltdoc="x">Product Projection</a></td></tr><tr><td><span class="tocsublinknumber">5.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_.Product_.Projection%29" class="tocsubseclink" data-pltdoc="x">Implementing Product Projection</a></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._.Function_.Domain%29" class="tocsubseclink" data-pltdoc="x">Function Domain</a></td></tr><tr><td><span class="tocsublinknumber">5.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_.Function_.Domain%29" class="tocsubseclink" data-pltdoc="x">Implementing Function Domain</a></td></tr><tr><td><span class="tocsublinknumber">5.3<tt>&nbsp;</tt></span><a href="#%28part._.Function_.Application%29" class="tocsubseclink" data-pltdoc="x">Function Application</a></td></tr><tr><td><span class="tocsublinknumber">5.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_.Function_.Application%29" class="tocsubseclink" data-pltdoc="x">Implementing Function Application</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.Strategies_for_.Testing%29" class="tocsubseclink" data-pltdoc="x">Strategies for Testing</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._doc-bibliography%29" class="tocsubseclink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.3</span></div><h2><a name="(part._.Down_and_.Dirty_with_.Semantic_.Set-theoretic_.Types__a_tutorial__v0_4)"></a>Down and Dirty with Semantic Set-theoretic
Types (a tutorial) v0.4</h2><p><a href="https://github.com/pnwamk/sst-tutorial/"><img src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub" style="position: absolute; top: 0; right: 0; border: 0;"/></a></p><p>Andrew M. Kent &lt;<a href="mailto:pnwamk@gmail.com">pnwamk@gmail.com</a>&gt;</p><p>Last updated: Monday, November 22nd, 2021</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Introduction%29" class="toptoclink" data-pltdoc="x">1<span class="hspace">&nbsp;</span>Introduction</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Prerequisites%29" class="toclink" data-pltdoc="x">1.1<span class="hspace">&nbsp;</span>Prerequisites</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Example_.Grammar_and_.Function_.Definitions%29" class="toclink" data-pltdoc="x">1.2<span class="hspace">&nbsp;</span>Example Grammar and Function Definitions</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aoverview%29" class="toptoclink" data-pltdoc="x">2<span class="hspace">&nbsp;</span>Set-theoretic Types: An Overview</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Subtyping%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>Subtyping</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3asemantic-subtyping%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>Semantic Subtyping</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3anorm-forms%29" class="toclink" data-pltdoc="x">2.3<span class="hspace">&nbsp;</span>Deciding Inhabitation, Normal Forms</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types_in_.Disjunctive_.Normal_.Form%29" class="toclink" data-pltdoc="x">2.3.1<span class="hspace">&nbsp;</span>Types in Disjunctive Normal Form</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3apartitioning-types%29" class="toclink" data-pltdoc="x">2.3.2<span class="hspace">&nbsp;</span>Partitioning Types</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3arep%29" class="toptoclink" data-pltdoc="x">3<span class="hspace">&nbsp;</span>Set-theoretic Type Representation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types_as_.Data_.Structures%29" class="toclink" data-pltdoc="x">3.1<span class="hspace">&nbsp;</span>Types as Data Structures</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Top_and_.Bottom_.Type_.Representation%29" class="toclink" data-pltdoc="x">3.1.1<span class="hspace">&nbsp;</span>Top and Bottom Type Representation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Type_.Operations%29" class="toclink" data-pltdoc="x">3.1.2<span class="hspace">&nbsp;</span>Type Operations</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3abase-type-rep%29" class="toclink" data-pltdoc="x">3.2<span class="hspace">&nbsp;</span>Base DNF Representation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Base_.D.N.F_.Operations%29" class="toclink" data-pltdoc="x">3.2.1<span class="hspace">&nbsp;</span>Base DNF Operations</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3abdd-rep%29" class="toclink" data-pltdoc="x">3.3<span class="hspace">&nbsp;</span>Product and Function DNFs</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Binary_.Decision_.Diagrams%29" class="toclink" data-pltdoc="x">3.3.1<span class="hspace">&nbsp;</span>Binary Decision Diagrams</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types_as_.B.D.Ds_%29" class="toclink" data-pltdoc="x">3.3.2<span class="hspace">&nbsp;</span>Types as BDDs?</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3atypes-as-lazy-bdds%29" class="toclink" data-pltdoc="x">3.3.3<span class="hspace">&nbsp;</span>Types as Lazy BDDs!</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Lazy_.B.D.D_.Operations%29" class="toclink" data-pltdoc="x">3.3.4<span class="hspace">&nbsp;</span>Lazy BDD Operations</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Parsing_and_.Example_.Types%29" class="toclink" data-pltdoc="x">3.4<span class="hspace">&nbsp;</span>Parsing and Example Types</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Implementing_.Semantic_.Subtyping%29" class="toptoclink" data-pltdoc="x">4<span class="hspace">&nbsp;</span>Implementing Semantic Subtyping</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Deciding_.Type_.Inhabitation%29" class="toclink" data-pltdoc="x">4.1<span class="hspace">&nbsp;</span>Deciding Type Inhabitation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aprod-inhabitation%29" class="toclink" data-pltdoc="x">4.1.1<span class="hspace">&nbsp;</span>Product Type Inhabitation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._sec~3aarrow-inhabitation%29" class="toclink" data-pltdoc="x">4.1.2<span class="hspace">&nbsp;</span>Function Type Inhabitation</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Other_.Key_.Type-level_.Functions%29" class="toptoclink" data-pltdoc="x">5<span class="hspace">&nbsp;</span>Other Key Type-level Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Product_.Projection%29" class="toclink" data-pltdoc="x">5.1<span class="hspace">&nbsp;</span>Product Projection</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Implementing_.Product_.Projection%29" class="toclink" data-pltdoc="x">5.1.1<span class="hspace">&nbsp;</span>Implementing Product Projection</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Function_.Domain%29" class="toclink" data-pltdoc="x">5.2<span class="hspace">&nbsp;</span>Function Domain</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Implementing_.Function_.Domain%29" class="toclink" data-pltdoc="x">5.2.1<span class="hspace">&nbsp;</span>Implementing Function Domain</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Function_.Application%29" class="toclink" data-pltdoc="x">5.3<span class="hspace">&nbsp;</span>Function Application</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Implementing_.Function_.Application%29" class="toclink" data-pltdoc="x">5.3.1<span class="hspace">&nbsp;</span>Implementing Function Application</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Strategies_for_.Testing%29" class="toptoclink" data-pltdoc="x">6<span class="hspace">&nbsp;</span>Strategies for Testing</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._doc-bibliography%29" class="toptoclink" data-pltdoc="x">Bibliography</a></p></td></tr></table><h3>1<tt>&nbsp;</tt><a name="(part._.Introduction)"></a>Introduction</h3><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>This is a &ldquo;living&rdquo; document: please submit bug reports
and pull requests if you spot a problem!
<a href="https://github.com/pnwamk/sst-tutorial/"><span class="url">https://github.com/pnwamk/sst-tutorial/</span></a></p></blockquote></blockquote></blockquote><p>This is an informal tutorial designed to:</p><ul><li><p>(1) briefly introduce semantic set-theoretic types, and</p></li><li><p>(2) describe in detail (i.e. with pseudo code) their
implementation details.</p></li></ul><p>Most of the "pseudo code" in this tutorial was generated
directly from a <span class="emph">functioning redex model</span>
<span class="Autobibref">&nbsp;(<a href="#%28autobib._.Casey._.Klein%2C._.John._.Clements%2C._.Christos._.Dimoulas%2C._.Carl._.Eastlund%2C._.Matthias._.Felleisen%2C._.Matthew._.Flatt%2C._.Jay._.A..._.Mc.Carthy%2C._.Jon._.Rafkind%2C._.Sam._.Tobin-.Hochstadt%2C._and._.Robert._.Bruce._.Findler.Run._.Your._.Research~3a._.On._the._.Effectiveness._of._.Lightweight._.Mechanization.In._.Proc..._.The._39th._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages._%28.P.O.P.L%292012%29" class="AutobibLink" data-pltdoc="x">Klein et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Casey._.Klein%2C._.John._.Clements%2C._.Christos._.Dimoulas%2C._.Carl._.Eastlund%2C._.Matthias._.Felleisen%2C._.Matthew._.Flatt%2C._.Jay._.A..._.Mc.Carthy%2C._.Jon._.Rafkind%2C._.Sam._.Tobin-.Hochstadt%2C._and._.Robert._.Bruce._.Findler.Run._.Your._.Research~3a._.On._the._.Effectiveness._of._.Lightweight._.Mechanization.In._.Proc..._.The._39th._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages._%28.P.O.P.L%292012%29" class="AutobibLink" data-pltdoc="x">2012</a>)</span> to greatly reduce the chance
for typos or other subtle bugs in their presentation.</p><p>We would like to thank Giuseppe Castagna for the time he
spent writing the wonderful, detailed manuscript <span class="emph">Covariance and Contravariance: a fresh look at an old issue
(a primer in advanced type systems for learning functional
programmers)</span> <span class="Autobibref">&nbsp;(<a href="#%28autobib._.Giuseppe._.Castagna.Covariance._and._.Contravariance~3a._a._fresh._look._at._an._old._issue._%28a._primer._in._advanced._type._systems._for._learning._functional._programmers%292013.Unpublished._manuscript%2C._periodically._updated..%29" class="AutobibLink" data-pltdoc="x">Castagna</a> <a href="#%28autobib._.Giuseppe._.Castagna.Covariance._and._.Contravariance~3a._a._fresh._look._at._an._old._issue._%28a._primer._in._advanced._type._systems._for._learning._functional._programmers%292013.Unpublished._manuscript%2C._periodically._updated..%29" class="AutobibLink" data-pltdoc="x">2013</a>)</span> which we used to
initially understand the implementation details we will
discuss, as well as Alain Frisch, Giuseppe Castagna, and
V&#233;ronique Benzaken for their detailed journal article <span class="emph">Semantic subtyping: Dealing set-theoretically with function,
union, intersection, and negation types</span>
<span class="Autobibref">&nbsp;(<a href="#%28autobib._.Alain._.Frisch%2C._.Giuseppe._.Castagna%2C._and._.V~c3~a9ronique._.Benzaken.Semantic._subtyping~3a._.Dealing._set-theoretically._with._function%2C._union%2C._intersection%2C._and._negation._types...Journal._of._the._.A.C.M._55%2819%292008%29" class="AutobibLink" data-pltdoc="x">Frisch et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Alain._.Frisch%2C._.Giuseppe._.Castagna%2C._and._.V~c3~a9ronique._.Benzaken.Semantic._subtyping~3a._.Dealing._set-theoretically._with._function%2C._union%2C._intersection%2C._and._negation._types...Journal._of._the._.A.C.M._55%2819%292008%29" class="AutobibLink" data-pltdoc="x">2008</a>)</span> which contains thorough
mathematical and technical descriptions of semantic
subtyping. Without those works this tutorial would simply
not be possible! We <span class="emph">highly</span> recommend perusing those
works as well for readers who are interested in this material.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._.Prerequisites)"></a>Prerequisites</h4><p>We assume the reader has some mathematical maturity and is
familiar with terminology commonly used by computer
scientists for describing programming languages and types.
In particular, we assume basic familiarity with:</p><ul><li><p>how types are generally used to describe programs,</p></li><li><p>basic set-theoretic concepts,</p></li><li><p>context-free grammars (CFGs), and</p></li><li><p>defining functions via pattern matching.</p></li></ul><h4>1.2<tt>&nbsp;</tt><a name="(part._.Example_.Grammar_and_.Function_.Definitions)"></a>Example Grammar and Function Definitions</h4><p>To be clear about how our term and function definitions
should be read we start by briefly examining a simple
well-understood domain: Peano natural numbers.</p><p>Here is a grammar for Peano naturals and booleans:</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict.png" alt="image" width="218.98681640625" height="99.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3apeano-grammar))" x-target-lift="Figure"></a>Figure&nbsp;1: </span>a context-free grammar for natural numbers and booleans</span></p></blockquote><p>This grammar states that a natural number is either <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_2.png" alt="image" width="22.33740234375" height="27.0"/>
(zero) or <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_3.png" alt="image" width="52.65673828125" height="27.0"/> (i.e. the successor of some natural
number p), and that a boolean must be either <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_4.png" alt="image" width="60.88916015625" height="27.0"/> or
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_5.png" alt="image" width="63.85107421875" height="27.0"/>.</p><p>We can then define the function <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_6.png" alt="image" width="43.46044921875" height="27.0"/> to be addition by
structural recursion on the first argument:</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_7.png" alt="image" width="231.9228515625" height="127.0546875"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3apeano-plus))" x-target-lift="Figure"></a>Figure&nbsp;2: </span>addition for natural numbers</span></p></blockquote><p>Example usages:</p><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_8.png" alt="image" width="227.22216796875" height="34.013671875"/></p><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_9.png" alt="image" width="227.22216796875" height="34.013671875"/></p><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_10.png" alt="image" width="367.14990234375" height="34.013671875"/></p><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_11.png" alt="image" width="22.33740234375" height="27.0"/> will be defined to be a function that returns a
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_12.png" alt="image" width="44.51220703125" height="27.0"/> indicating whether the first argument is strictly
less than the second:</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_13.png" alt="image" width="223.13671875" height="99.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3apeano-lt))" x-target-lift="Figure"></a>Figure&nbsp;3: </span>less than for natural numbers</span></p></blockquote><p>Example usages:</p><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_14.png" alt="image" width="190.79150390625" height="27.0"/></p><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_15.png" alt="image" width="187.82958984375" height="27.0"/></p><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_16.png" alt="image" width="257.79345703125" height="27.0"/></p><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_17.png" alt="image" width="22.33740234375" height="27.0"/> will be defined to be a function that returns a
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_18.png" alt="image" width="44.51220703125" height="27.0"/> indicating whether the first argument is strictly
greater-than the second:</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_19.png" alt="image" width="173.818359375" height="102.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3apeano-gt))" x-target-lift="Figure"></a>Figure&nbsp;4: </span>greater than for natural numbers</span></p></blockquote><p>Example usages:</p><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_20.png" alt="image" width="187.82958984375" height="27.0"/></p><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_21.png" alt="image" width="190.79150390625" height="27.0"/></p><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_22.png" alt="image" width="260.75537109375" height="27.0"/></p><p>Things to note about these definitions (and about
definitions in general):</p><ul><li><p>The first line is the <span class="emph">signature</span> of the
function and tells us how many arguments the function takes
in addition to the types the inputs and outputs will have.
e.g., <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_23.png" alt="image" width="43.46044921875" height="27.0"/> takes two natural numbers and returns a
natural number;</p></li><li><p>Underscores that appear <span class="emph">in the signature</span> of a
function are simply indicators for where arguments will go
for functions with non-standard usage syntax. e.g.,
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_24.png" alt="image" width="43.46044921875" height="27.0"/> does not use underscores because we use standard
function application syntax to talk about its application
(e.g. <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_25.png" alt="image" width="106.41357421875" height="27.0"/>), but <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_26.png" alt="image" width="22.33740234375" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_27.png" alt="image" width="22.33740234375" height="27.0"/> use
underscores to indicate they will be used as <span class="emph">infix</span>
operators (i.e. we will write <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_28.png" alt="image" width="59.0419921875" height="27.0"/> inbetween the
two arguments instead of at the front like <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_29.png" alt="image" width="43.46044921875" height="27.0"/>);</p></li><li><p>Underscores used <span class="emph">within the definition</span> of the
function (e.g. the second and third clauses for <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_30.png" alt="image" width="22.33740234375" height="27.0"/>) are
"wild-card" patterns and will match any input;</p></li><li><p>The order of function clauses matters! i.e. when
determining which clause of a function applies to a
particular input, the function tests each clause <span class="emph"> in
order</span> to see if the input matches the pattern(s);</p></li><li><p>In addition to pattern matching against the arguments
themselves, "where clauses" also act as "pattern matching
constraints" when present, e.g. <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_31.png" alt="image" width="22.33740234375" height="27.0"/>&rsquo;s first clause
matches on any naturals <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_32.png" alt="image" width="17.6748046875" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_33.png" alt="image" width="17.08740234375" height="27.0"/> <span class="emph">only
where</span> <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_34.png" alt="image" width="59.0419921875" height="27.0"/> equals <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_35.png" alt="image" width="60.88916015625" height="27.0"/>.</p></li><li><p>When the same non-terminal variable appears in two
places in a pattern, that pattern matches only if the same
term appears in both places. Note: this does not apply to
function <span class="emph">signatures</span>, where non-terminals only
indicate what <span class="emph">kind</span> of terms are accepted/returned.</p></li></ul><p><span style="font-weight: bold">Important Note:</span> We will "overload" certain convenient
symbols during the course of our discussion since we can
always distinguish them based on the types of arguments they
are given. e.g. we will define several "union" operations,
all of which will use the standard set-theoretic symbol
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_36.png" alt="image" width="20.0068359375" height="27.0"/>. But when we see <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_37.png" alt="image" width="62.28515625" height="27.0"/> and
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_38.png" alt="image" width="69.298828125" height="27.0"/>, for example, we will know the former
usage of <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_39.png" alt="image" width="20.0068359375" height="27.0"/> is the version explicitly defined to
operate on <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_40.png" alt="image" width="14.16796875" height="27.0"/>&rsquo;s and the latter is the version explicitly
defined to operate on <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_41.png" alt="image" width="17.6748046875" height="27.0"/>&rsquo;s. Like the function
definitions above, <span class="emph">all</span> function definitions will have
clear signatures describing the kinds of arguments they
operate on.</p><h3>2<tt>&nbsp;</tt><a name="(part._sec~3aoverview)"></a>Set-theoretic Types: An Overview</h3><p>Set-theoretic types are a flexible and natural way for
describing sets of values, featuring intuitive "logical
combinators" in addition to traditional types for creating
detailed specifications.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_42.png" alt="image" width="559.8603515625" height="106.6416015625"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3atypes))" x-target-lift="Figure"></a>Figure&nbsp;5: </span>set-theoretic types</span></p></blockquote><p>As <a href="#%28counter._%28figure._fig~3atypes%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">5</span></a> illustrates, languages with
set-theoretic types feature (at least some of) the following
logical type constructors:</p><ul><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_43.png" alt="image" width="57.65771484375" height="27.0"/> is the union of types <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_44.png" alt="image" width="17.1298828125" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_45.png" alt="image" width="18.57861328125" height="27.0"/>,
describing values of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_46.png" alt="image" width="17.1298828125" height="27.0"/> <span class="emph">or</span> of
type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_47.png" alt="image" width="18.57861328125" height="27.0"/>;</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_48.png" alt="image" width="57.65771484375" height="27.0"/> is the intersection of types <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_49.png" alt="image" width="17.1298828125" height="27.0"/> and
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_50.png" alt="image" width="18.57861328125" height="27.0"/>, describing values of both type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_51.png" alt="image" width="17.1298828125" height="27.0"/>
<span class="emph">and</span> <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_52.png" alt="image" width="18.57861328125" height="27.0"/>;</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_53.png" alt="image" width="38.10791015625" height="27.0"/> is the complement (or negation) of
type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_54.png" alt="image" width="17.1298828125" height="27.0"/>, describing values <span class="emph">not</span> of type
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_55.png" alt="image" width="17.1298828125" height="27.0"/>;</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_56.png" alt="image" width="39.0732421875" height="33.32080078125"/> is the type describing all possible values; and</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_57.png" alt="image" width="61.1220703125" height="33.32080078125"/> is the type describing no values (i.e. <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_58.png" alt="image" width="60.05126953125" height="33.32080078125"/>).</p></li></ul><p>Additionally, we may specify "specific top types", which for
each kind of atomic type denotes all values of that
particular kind:</p><ul><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_59.png" alt="image" width="48.40869140625" height="33.32080078125"/> is the type that denotes all pairs,</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_60.png" alt="image" width="51.0732421875" height="33.32080078125"/> is the type that denotes all function, and</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_61.png" alt="image" width="42.76904296875" height="33.32080078125"/> is the type that denotes all base
values (i.e. integers, strings, and booleans).</p></li></ul><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_62.png" alt="image" width="224.51806640625" height="117.96240234375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aspecific-top-types))" x-target-lift="Figure"></a>Figure&nbsp;6: </span>specific top type definitions</span></p></blockquote><p>Set theoretic types frequently appear in type systems which
reason about dynamically typed languages (e.g. TypeScript,
Flow, Typed Racket, Typed Clojure, Julia), but some statically
typed languages use them as well (e.g. CDuce, Pony).</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.Subtyping)"></a>Subtyping</h4><p>With set-theoretic types, the programmer (and the type
system) must be able to reason about how types that are not
equivalent relate. i.e., even though <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_63.png" alt="image" width="17.1298828125" height="27.0"/> is not the same
type as <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_64.png" alt="image" width="18.57861328125" height="27.0"/>, is it the case that a value of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_65.png" alt="image" width="17.1298828125" height="27.0"/>
will necessarily also be a value of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_66.png" alt="image" width="18.57861328125" height="27.0"/>? In other
words, does <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_67.png" alt="image" width="65.82568359375" height="27.0"/> hold (i.e. is &#964; a subtype of &#963;)?</p><p>For example, consider the following subtyping question:</p><blockquote class="SCentered"><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_68.png" alt="image" width="469.37548828125" height="33.32080078125"/></p></blockquote><p>Clearly the two types are not equal... but we can also see
that any pair whose first element is either an integer or a
string and whose second element is a string (i.e. the type
on the left-hand side) is indeed either a pair with an
integer and a string or a pair with a string and a string
(i.e. the type on the right-hand side). As a programmer then
we might reasonably expect that anywhere a
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_69.png" alt="image" width="259.4736328125" height="33.32080078125"/> is expected, we
could provide a value of type <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_70.png" alt="image" width="179.78466796875" height="33.32080078125"/>
and things should work just fine.</p><p>Unfortunately, many (most?) systems that feature
set-theoretic types use sound but incomplete reasoning to
determine subtyping. This is because most type
systems reason about subtyping via syntactic inference
rules:</p><blockquote class="SCentered"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_71.png" alt="image" width="505.16015625" height="144.56201171875"/></p></blockquote><p>These rules allow us to conclude the statement below the
line if we can show that the statement(s) above the line
hold. Upsides to using a system built from rules like this
include (1) the rules can often directly be translated into
efficient code and (2) we can generally examine each rule
individually and decide if the antecedants necessarily imply
the consequent (i.e. determine if the rule is valid). The
downside is that such rules are incomplete for set-theoretic
types: it is impossible to derive all valid subtyping
judgments, e.g. we cannot conclude
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_72.png" alt="image" width="179.78466796875" height="33.32080078125"/> is a subtype of
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_73.png" alt="image" width="259.4736328125" height="33.32080078125"/> even though it is
true.</p><p>For a complete treatment of subtyping for set-theoretic
types, a <span class="emph">semantic</span> (instead of a syntactic) notion of
subtyping is required.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>At the time of writing this tutorial, CDuce may
be the only example of an in-use language with a type system
which features set-theoretic types <span class="emph">and</span> complete
subtyping. This is not surprising since its developers are
also the researchers that have pioneered the approaches we
will discuss.</p></blockquote></blockquote></blockquote><h4>2.2<tt>&nbsp;</tt><a name="(part._sec~3asemantic-subtyping)"></a>Semantic Subtyping</h4><p>Instead of using a syntactic approach to reason about
subtyping, we will instead us a semantic approach: types
will simply denote sets of values in the language in the
expected way.</p><ul><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_74.png" alt="image" width="50.09765625" height="33.32080078125"/> denotes singleton set <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_75.png" alt="image" width="81.88916015625" height="27.0"/>;</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_76.png" alt="image" width="61.1220703125" height="33.32080078125"/> denotes singleton set <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_77.png" alt="image" width="84.85107421875" height="27.0"/>;</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_78.png" alt="image" width="39.0732421875" height="33.32080078125"/> denotes the set of integers;</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_79.png" alt="image" width="39.0732421875" height="33.32080078125"/> denotes the set of strings;</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_80.png" alt="image" width="59.98828125" height="27.0"/> denotes the set of pairs whose first
element is a value in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_81.png" alt="image" width="17.1298828125" height="27.0"/> and whose second element is a
value in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_82.png" alt="image" width="18.57861328125" height="27.0"/> (i.e. the cartesian product of <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_83.png" alt="image" width="17.1298828125" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_84.png" alt="image" width="18.57861328125" height="27.0"/>);</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_85.png" alt="image" width="64.65087890625" height="27.0"/> denotes the set of functions which can
be applied to a value in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_86.png" alt="image" width="17.1298828125" height="27.0"/> and will return a value from
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_87.png" alt="image" width="18.57861328125" height="27.0"/> (if they return);</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_88.png" alt="image" width="57.65771484375" height="27.0"/> denotes the union of the sets denoted
by <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_89.png" alt="image" width="17.1298828125" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_90.png" alt="image" width="18.57861328125" height="27.0"/>;</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_91.png" alt="image" width="57.65771484375" height="27.0"/> denotes the intersection of the sets denoted
by <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_92.png" alt="image" width="17.1298828125" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_93.png" alt="image" width="18.57861328125" height="27.0"/>;</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_94.png" alt="image" width="38.10791015625" height="27.0"/> denotes the complement of the set denoted
by <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_95.png" alt="image" width="17.1298828125" height="27.0"/>;</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_96.png" alt="image" width="39.0732421875" height="33.32080078125"/> denotes the set of all values; and</p></li><li><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_97.png" alt="image" width="61.1220703125" height="33.32080078125"/> denotes the empty set.</p></li></ul><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Our description here omits many interesting
subtleties and details about why this approach more or less
"just works"; <span class="Autobibref"><a href="#%28autobib._.Alain._.Frisch%2C._.Giuseppe._.Castagna%2C._and._.V~c3~a9ronique._.Benzaken.Semantic._subtyping~3a._.Dealing._set-theoretically._with._function%2C._union%2C._intersection%2C._and._negation._types...Journal._of._the._.A.C.M._55%2819%292008%29" class="AutobibLink" data-pltdoc="x">Frisch et al<span class="Sendabbrev">.</span></a>&nbsp;(<a href="#%28autobib._.Alain._.Frisch%2C._.Giuseppe._.Castagna%2C._and._.V~c3~a9ronique._.Benzaken.Semantic._subtyping~3a._.Dealing._set-theoretically._with._function%2C._union%2C._intersection%2C._and._negation._types...Journal._of._the._.A.C.M._55%2819%292008%29" class="AutobibLink" data-pltdoc="x">2008</a>)</span> <span class="emph">thoroughly</span> discuss this topic and much more and should be
consulted if the reader is so inclined.</p></blockquote></blockquote></blockquote><p>With our types merely denoting sets of values, subtyping can
be determined by deciding type inhabitation
(<a href="#%28counter._%28figure._fig~3asubtype-is-emptiness%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">7</span></a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_98.png" alt="image" width="529.1494140625" height="28.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asubtype-is-emptiness))" x-target-lift="Figure"></a>Figure&nbsp;7: </span>subtyping/inhabitation equivalence</span></p></blockquote><p>In other words, <span style="font-weight: bold">"is a particular type inhabited" is
really the only question we have to be able to answer</span> since
asking <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_99.png" alt="image" width="65.82568359375" height="27.0"/> is the same as asking if
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_100.png" alt="image" width="78.6357421875" height="27.0"/> is uninhabited (i.e. does it denote the
empty set?).</p><h4>2.3<tt>&nbsp;</tt><a name="(part._sec~3anorm-forms)"></a>Deciding Inhabitation, Normal Forms</h4><p>To efficiently decide type inhabitation for set-theoretic
types we leverage some of the same strategies used to decide
boolean satisfiability:</p><ul><li><p>types are kept in disjunctive normal form (DNF), and</p></li><li><p>special data structures are used to efficiently
represent DNF types.</p></li></ul><h5>2.3.1<tt>&nbsp;</tt><a name="(part._.Types_in_.Disjunctive_.Normal_.Form)"></a>Types in Disjunctive Normal Form</h5><p>In addition to using DNF, it will be helpful to impose some
additional structure to our normal form for types. To
illustrate, first let us note that a DNF boolean formula
<img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_101.png" alt="image" width="21.279296875" height="26.0"/>:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_102.png" alt="image" width="313.0615234375" height="104.0"/></p></blockquote><p>can be reorganized slightly to "group" the positive and
negative atoms in each conjunction:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_103.png" alt="image" width="378.140625" height="104.0"/></p></blockquote><p>We then observe that <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_104.png" alt="image" width="21.279296875" height="26.0"/> can be described as a set of
pairs, with one pair <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_105.png" alt="image" width="55.7373046875" height="26.0"/> for each clause in the original
disjunction, where <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_106.png" alt="image" width="19.619140625" height="26.0"/> is the set of positive atoms in the
clause and <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_107.png" alt="image" width="21.0" height="26.0"/> is the set of negated atoms in the clause:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_108.png" alt="image" width="359.5068359375" height="105.7447509765625"/></p></blockquote><p>Similarly, any type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_109.png" alt="image" width="17.1298828125" height="27.0"/> can be converted into a DNF, i.e.
a set of pairs <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_110.png" alt="image" width="55.7373046875" height="26.0"/>, where for each clause <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_111.png" alt="image" width="55.7373046875" height="26.0"/>,
<img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_112.png" alt="image" width="19.619140625" height="26.0"/> contains the positive atoms (written <span style="font-style: italic">a</span>) which
are either a base type (<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_113.png" alt="image" width="12.46728515625" height="27.0"/>), a product type
(<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_114.png" alt="image" width="70.53955078125" height="27.0"/>), or function type
(<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_115.png" alt="image" width="75.2021484375" height="27.0"/>), and <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_116.png" alt="image" width="21.0" height="26.0"/> contains the negated atoms:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_117.png" alt="image" width="352.1513671875" height="104.729736328125"/></p></blockquote><h5>2.3.2<tt>&nbsp;</tt><a name="(part._sec~3apartitioning-types)"></a>Partitioning Types</h5><p>In addition to being able to convert any type into DNF, for
any type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_118.png" alt="image" width="17.1298828125" height="27.0"/> there exists three specialized types
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_119.png" alt="image" width="20.8251953125" height="27.0"/>, <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_120.png" alt="image" width="26.4658203125" height="27.0"/>, and
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_121.png" alt="image" width="29.1298828125" height="27.0"/> which contain <span class="emph">only atoms of the
same kind</span> such that:</p><blockquote class="SCentered"><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_122.png" alt="image" width="408.412109375" height="33.32080078125"/></p></blockquote><p>By representing a type in this way, we can efficiently
divide types into non-overlapping segments which can each
have their own DNF representation.</p><p>i.e., <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_123.png" alt="image" width="20.8251953125" height="27.0"/> is a type whose atoms are all base types:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_124.png" alt="image" width="338.6953125" height="104.729736328125"/></p></blockquote><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_125.png" alt="image" width="26.4658203125" height="27.0"/> is a DNF type whose atoms are all product types:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_126.png" alt="image" width="489.74072265625" height="106.4593505859375"/></p></blockquote><p>and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_127.png" alt="image" width="29.1298828125" height="27.0"/> is a DNF type whose atoms are all function
types:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_128.png" alt="image" width="501.72998046875" height="106.4593505859375"/></p></blockquote><p>To illustrate what this partitioning looks like in practice,
here are a few very simple types and their equivalent
"partitioned" representation:</p><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_129.png" alt="image" width="568.4970703125" height="33.32080078125"/>
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_130.png" alt="image" width="480.3017578125" height="33.32080078125"/>
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_131.png" alt="image" width="524.3994140625" height="33.32080078125"/>
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_132.png" alt="image" width="667.44140625" height="33.32080078125"/>
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_133.png" alt="image" width="676.7666015625" height="33.32080078125"/>
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_134.png" alt="image" width="722.7509765625" height="33.32080078125"/></p><p>This technique for partitioning types into separate
non-overlapping DNFs&#8212;<wbr></wbr>which will inform our strategy for
actually representing types as data structures&#8212;<wbr></wbr>will make
type inhabitation inquiries easier to implement since we&rsquo;re
specializing our representation to describe only the
interesting, non-trivial clauses in a type. We summarize
this discussion&rsquo;s key takeaway in
<a href="#%28counter._%28figure._fig~3atype-canonical-form%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a> for reference.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_135.png" alt="image" width="663.3642578125" height="458.96923828125"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3atype-canonical-form))" x-target-lift="Figure"></a>Figure&nbsp;8: </span>canonical form for representing types</span></p></blockquote><h3>3<tt>&nbsp;</tt><a name="(part._sec~3arep)"></a>Set-theoretic Type Representation</h3><p>In <a href="#%28part._sec~3aoverview%29" data-pltdoc="x">Set-theoretic Types: An Overview</a> we determined that</p><ul><li><p>many type-related inquiries for set-theoretic types
can be reduced to deciding type inhabitation (see
<a href="#%28part._sec~3asemantic-subtyping%29" data-pltdoc="x">Semantic Subtyping</a>), and that because of
this</p></li><li><p>a partitioned DNF representation (summarized in
<a href="#%28counter._%28figure._fig~3atype-canonical-form%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a>) may be useful.</p></li></ul><p>In this section we focus on the latter issue: type
representation (since how we represent types impacts how our
algorithms decide type inhabitation). We will introduce
several data structures, defining for each the binary
operators union ("&#8746;"), intersection ("&#8745;"), and difference
("\") and the unary operator complement ("&#172;").</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Types_as_.Data_.Structures)"></a>Types as Data Structures</h4><p>In <a href="#%28counter._%28figure._fig~3atype-canonical-form%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a> we noted a type
can be conveniently deconstructed into three partitions,
allowing us to reason separately about the base type
(<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_136.png" alt="image" width="20.8251953125" height="27.0"/>), product type
(<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_137.png" alt="image" width="26.4658203125" height="27.0"/>), and function type
(<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_138.png" alt="image" width="29.1298828125" height="27.0"/>) portion of a type:</p><blockquote class="SCentered"><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_139.png" alt="image" width="408.412109375" height="33.32080078125"/></p></blockquote><p>Our representation of types will exactly mirror this structure.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_140.png" alt="image" width="252.8173828125" height="52.5"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3atype-rep))" x-target-lift="Figure"></a>Figure&nbsp;9: </span>internal type representation</span></p></blockquote><p>As <a href="#%28counter._%28figure._fig~3atype-rep%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">9</span></a> indicates, our internal
representation of types is a 3-tuple:</p><ul><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_141.png" alt="image" width="17.71728515625" height="27.0"/> (the first field) is the portion which
contains base type information, corresponding to
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_142.png" alt="image" width="20.8251953125" height="27.0"/>;</p></li><li><p><img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_143.png" alt="image" width="19.7607421875" height="34.5"/> (the second field) is the portion
corresponding to product type information, corresponding to
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_144.png" alt="image" width="26.4658203125" height="27.0"/>; and</p></li><li><p><img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_145.png" alt="image" width="25.0166015625" height="34.5"/> (the third field) is the portion
corresponding to function type information, corresponding to
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_146.png" alt="image" width="29.1298828125" height="27.0"/>;</p></li></ul><p>The specific top types used in
<a href="#%28counter._%28figure._fig~3atype-canonical-form%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a> are implicit in our
representation, i.e. we know what kind of type-information
each field is responsible for so we need not explicitly keep
around <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_147.png" alt="image" width="42.76904296875" height="33.32080078125"/>, <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_148.png" alt="image" width="48.40869140625" height="33.32080078125"/>, and <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_149.png" alt="image" width="51.0732421875" height="33.32080078125"/> in our
partitioned representation.</p><p>The grammar and meaning for <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_150.png" alt="image" width="17.71728515625" height="27.0"/> will be given in
<a href="#%28part._sec~3abase-type-rep%29" data-pltdoc="x">Base DNF Representation</a> and for <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_151.png" alt="image" width="19.7607421875" height="34.5"/> and
<img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_152.png" alt="image" width="25.0166015625" height="34.5"/> will be given in <a href="#%28part._sec~3abdd-rep%29" data-pltdoc="x">Product and Function DNFs</a>.</p><h5>3.1.1<tt>&nbsp;</tt><a name="(part._.Top_and_.Bottom_.Type_.Representation)"></a>Top and Bottom Type Representation</h5><p>The representation of the "top type" <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_153.png" alt="image" width="39.0732421875" height="33.32080078125"/>&#8212;<wbr></wbr>the type
that denotes all values&#8212;<wbr></wbr>is written <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_154.png" alt="image" width="17.525390625" height="34.13671875"/> and is
defined by placing the top <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_155.png" alt="image" width="17.71728515625" height="27.0"/>, <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_156.png" alt="image" width="19.7607421875" height="34.5"/>, and
<img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_157.png" alt="image" width="25.0166015625" height="34.5"/> in each respective field
(<a href="#%28counter._%28figure._fig~3atop-type-rep%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">10</span></a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_158.png" alt="image" width="173.0009765625" height="35.1240234375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3atop-type-rep))" x-target-lift="Figure"></a>Figure&nbsp;10: </span>top type representation</span></p></blockquote><p>This mirrors the previous "partitioned" version of <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_159.png" alt="image" width="39.0732421875" height="33.32080078125"/>
we showed earlier:</p><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_160.png" alt="image" width="480.3017578125" height="33.32080078125"/></p><p>The representation of the "bottom type" <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_161.png" alt="image" width="61.1220703125" height="33.32080078125"/>&#8212;<wbr></wbr>the
type that denotes no values&#8212;<wbr></wbr>is written <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_162.png" alt="image" width="17.525390625" height="34.13671875"/> and is
defined by placing the bottom <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_163.png" alt="image" width="17.71728515625" height="27.0"/>, <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_164.png" alt="image" width="19.7607421875" height="34.5"/>, and
<img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_165.png" alt="image" width="25.0166015625" height="34.5"/> in each respective field
(<a href="#%28counter._%28figure._fig~3abot-type-rep%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">11</span></a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_166.png" alt="image" width="173.0009765625" height="35.1240234375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abot-type-rep))" x-target-lift="Figure"></a>Figure&nbsp;11: </span>bottom type representation</span></p></blockquote><p>Again, this mirrors the previous "partitioned" version of
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_167.png" alt="image" width="61.1220703125" height="33.32080078125"/> we showed earlier:</p><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_168.png" alt="image" width="568.4970703125" height="33.32080078125"/></p><p><a href="#%28counter._%28figure._fig~3aspecific-top-type-rep%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">12</span></a> describes how we
represent the specific top types <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_169.png" alt="image" width="42.76904296875" height="33.32080078125"/>,
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_170.png" alt="image" width="48.40869140625" height="33.32080078125"/>, and <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_171.png" alt="image" width="51.0732421875" height="33.32080078125"/> as data structures.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_172.png" alt="image" width="184.8427734375" height="124.4619140625"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aspecific-top-type-rep))" x-target-lift="Figure"></a>Figure&nbsp;12: </span>specific top type representations</span></p></blockquote><h5>3.1.2<tt>&nbsp;</tt><a name="(part._.Type_.Operations)"></a>Type Operations</h5><p>Binary operations on types benefit from our partitioned
design: each is defined pointwise in the natural way on
each partition; type complement is defined in terms of type
difference, subtracting the negated type from the top type
(<a href="#%28counter._%28figure._fig~3atype-ops%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">13</span></a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_173.png" alt="image" width="529.91455078125" height="305.63671875"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3atype-ops))" x-target-lift="Figure"></a>Figure&nbsp;13: </span>internal type operations</span></p></blockquote><h4>3.2<tt>&nbsp;</tt><a name="(part._sec~3abase-type-rep)"></a>Base DNF Representation</h4><p>We now examine how a DNF type with only base type atoms can
be efficiently represented (i.e. the base portion <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_174.png" alt="image" width="20.8251953125" height="27.0"/>
of a type described in
<a href="#%28counter._%28figure._fig~3atype-canonical-form%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a> and the <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_175.png" alt="image" width="17.71728515625" height="27.0"/> field
in our representation of types described in
<a href="#%28counter._%28figure._fig~3atype-rep%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">9</span></a>).</p><p>Although any type can be represented by some DNF type, in
the case of base types things can be simplified even
further! Any DNF type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_176.png" alt="image" width="20.8251953125" height="27.0"/> whose atoms are all base
types is equivalent to either</p><ul><li><p>a union of base types
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_177.png" alt="image" width="116.41015625" height="27.0"/>, or</p></li><li><p>a negated union of base types
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_178.png" alt="image" width="129.75" height="27.0"/>.</p></li></ul><p>To see why this is the case, it may be helpful to recall
that each base type is disjoint (i.e. no values inhabit more
than one base type), note that this is obviously true for
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_179.png" alt="image" width="39.0732421875" height="33.32080078125"/>, <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_180.png" alt="image" width="61.1220703125" height="33.32080078125"/>, and any a single base type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_181.png" alt="image" width="12.46728515625" height="27.0"/> or
negated base type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_182.png" alt="image" width="33.4453125" height="27.0"/>, and then examine the
definitions of base type operations presented in
<a href="#%28counter._%28figure._fig~3abase-type-ops%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a> and note how the
representation is naturally maintained.</p><p>Because any DNF of base types can be represented by a set of
base types (i.e. the elements in the union) and a polarity
(i.e. is the union negated or not), we represent the base
portion of a type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_183.png" alt="image" width="17.71728515625" height="27.0"/> using a tuple with these two pieces
of information (<a href="#%28counter._%28figure._fig~3abase-type-rep%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">14</span></a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_184.png" alt="image" width="201.4833984375" height="150.013671875"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abase-type-rep))" x-target-lift="Figure"></a>Figure&nbsp;14: </span>internal base type representation</span></p></blockquote><p>The first field is the polarity flag (either <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_185.png" alt="image" width="17.0244140625" height="34.013671875"/> for a
union or <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_186.png" alt="image" width="17.0244140625" height="34.013671875"/> for a negated union) and the second field
is the set of base types <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_187.png" alt="image" width="20.86669921875" height="27.0"/> in the union.</p><p>The top base type (i.e. the type which denotes all base type
values) is a negated empty set <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_188.png" alt="image" width="67.1689453125" height="34.013671875"/> (i.e. it
is not the case that this type contains no base values) and
the bottom base type (the type which denotes no base type
values) is a positive empty set <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_189.png" alt="image" width="67.1689453125" height="34.013671875"/> (i.e. it
is the case that this type contains no base values).</p><h5>3.2.1<tt>&nbsp;</tt><a name="(part._.Base_.D.N.F_.Operations)"></a>Base DNF Operations</h5><p>Operations on these base type representations boil down to
selecting the appropriate set-theoretic operation to combine
the sets based on the polarities
(<a href="#%28counter._%28figure._fig~3abase-type-ops%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">15</span></a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_190.png" alt="image" width="302.15185546875" height="461.1640625"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abase-type-ops))" x-target-lift="Figure"></a>Figure&nbsp;15: </span>internal base DNF operations</span></p></blockquote><p>Base type negation is not shown (because it is not used
anywhere in this model), but would simply require "flipping"
the polarity flag (i.e. the first field in the tuple).</p><h4>3.3<tt>&nbsp;</tt><a name="(part._sec~3abdd-rep)"></a>Product and Function DNFs</h4><p>In order to efficiently represent a DNF type with only
product or function type atoms (i.e. the <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_191.png" alt="image" width="26.4658203125" height="27.0"/> and
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_192.png" alt="image" width="29.1298828125" height="27.0"/> portions of a type described in
<a href="#%28counter._%28figure._fig~3atype-canonical-form%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a> and the <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_193.png" alt="image" width="19.7607421875" height="34.5"/>
and <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_194.png" alt="image" width="25.0166015625" height="34.5"/> fields in our type representation described
in <a href="#%28counter._%28figure._fig~3atype-rep%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">9</span></a>) we will use a binary decision
diagram (BDD).</p><p>First we include a brief review of how BDDs work, then we
discuss how they can be used effectively to represent our
product/function DNF types.</p><h5>3.3.1<tt>&nbsp;</tt><a name="(part._.Binary_.Decision_.Diagrams)"></a>Binary Decision Diagrams</h5><p>A binary decision diagram (BDD) is a tree-like data structure
which provides a convenient way to represent sets or
relations.</p><p>For example, the boolean formula
<img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_195.png" alt="image" width="243.2919921875" height="26.0"/> has truth table:</p><blockquote class="SCentered"><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="left" style="border-bottom: 1px solid black;"><p><img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_196.png" alt="image" width="16.5595703125" height="26.0"/></p></td><td align="left" style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left" style="border-bottom: 1px solid black;"><p><img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_197.png" alt="image" width="16.5595703125" height="26.0"/></p></td><td align="left" style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left" style="border-bottom: 1px solid black;"><p><img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_198.png" alt="image" width="14.8798828125" height="26.0"/></p></td><td align="left" style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center" style="border-bottom: 1px solid black;"><p><img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_199.png" alt="image" width="243.2919921875" height="26.0"/></p></td></tr><tr><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center"><p>1</p></td></tr><tr><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center"><p>0</p></td></tr><tr><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center"><p>0</p></td></tr><tr><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center"><p>1</p></td></tr><tr><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center"><p>0</p></td></tr><tr><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center"><p>0</p></td></tr><tr><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>0</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center"><p>1</p></td></tr><tr><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="left"><p>1</p></td><td align="left"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td align="center"><p>1</p></td></tr></table></blockquote><p>and can be represented with the following BDD:</p><blockquote class="SCentered"><p><img style="vertical-align: -5.0px; margin: -3px -3px -3px -3px;" src="pict_200.png" alt="image" width="278.68310546875" height="232.0"/></p></blockquote><p>Each node in the tree contains a boolean variable. A node&rsquo;s
left subtree (the blue edge) describes the "residual
formula" for when that variable is true. The node&rsquo;s right
subtree (the red edge) describes the "residual formula" when
that variable is false. We invite the reader to compare the
truth table and corresponding BDD until they are convinced
they indeed represent the same boolean formula. It may be
useful to observe that the leaves in the BDD correspond to
the right-most column in the truth table.</p><h5>3.3.2<tt>&nbsp;</tt><a name="(part._.Types_as_.B.D.Ds_)"></a>Types as BDDs?</h5><p>BDDs can also naturally encode set-theoretic types (in our
case, DNF product or function types). Each node has a
function/product type associated with it; henceforth we will
call this associated type the <span class="emph">atom</span> of the node. A
node&rsquo;s left sub-tree (the blue edge) describes the "residual
type" for when the atom is included in the overall type. A
node&rsquo;s right sub-tree (the red edge) describes the "residual
type" for when the atom&rsquo;s <span class="emph">negation</span> is included in
the overall type.</p><p>For example, here we have encoded the type
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_201.png" alt="image" width="102.42626953125" height="33.32080078125"/>:</p><blockquote class="SCentered"><p><img style="vertical-align: -5.0px; margin: -3px -3px -3px -3px;" src="pict_202.png" alt="image" width="195.663818359375" height="129.46240234375"/></p></blockquote><p>and here is
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_203.png" alt="image" width="259.4736328125" height="33.32080078125"/>:</p><blockquote class="SCentered"><p><img style="vertical-align: -5.0px; margin: -3px -3px -3px -3px;" src="pict_204.png" alt="image" width="357.8154296875" height="211.4248046875"/></p></blockquote><p>Basically, each path in the tree represents a clause in the
overall DNF, so the overall type is the union of all the
possibly inhabited paths (i.e. paths that end in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_205.png" alt="image" width="17.6748046875" height="27.0"/>).</p><p>In other words, for an arbitrary (type) BDD</p><blockquote class="SCentered"><p><img style="vertical-align: -5.0px; margin: -3px -3px -3px -3px;" src="pict_206.png" alt="image" width="128.164306640625" height="110.5"/></p></blockquote><p>we would interpret the meaning of <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_207.png" alt="image" width="17.6748046875" height="27.0"/> (written&#12314;<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_208.png" alt="image" width="17.6748046875" height="27.0"/>&#12315;)
as follows:</p><blockquote class="SCentered"><p><img style="vertical-align: -5.419921875px; margin: -3px -3px -3px -3px;" src="pict_209.png" alt="image" width="352.11474609375" height="32.796875"/></p></blockquote><p>where <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_210.png" alt="image" width="17.6748046875" height="27.0"/> is interpreted as <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_211.png" alt="image" width="39.0732421875" height="33.32080078125"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_212.png" alt="image" width="17.6748046875" height="27.0"/> as
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_213.png" alt="image" width="61.1220703125" height="33.32080078125"/>.</p><p>There is, however, a well-known problem with BDDs we will
want to avoid: repeatedly unioning trees can lead to
significant increases in size. This is particularly
frustrating because&#8212;<wbr></wbr>as we have previously noted&#8212;<wbr></wbr>our
primary concern algorithmically is deciding type
inhabitation and taking the union of two types will have no
<span class="emph">interesting</span> impact with respect to inhabitation. This
is because the union of two types is uninhabited only when
both the individual types themselves are already
uninhabited.</p><h5>3.3.3<tt>&nbsp;</tt><a name="(part._sec~3atypes-as-lazy-bdds)"></a>Types as Lazy BDDs!</h5><p>Because there is no interesting impact on inhabitation when
computing unions, we can use "lazy" BDDs&#8212;<wbr></wbr>whose unions
only fully expand when computing type intersection or
difference (i.e. operations that <span class="emph">can</span> have an
interesting impact on inhabitation)&#8212;<wbr></wbr>to represent our
function/product DNF types.</p><p>Nodes in lazy BDDs have&#8212;<wbr></wbr>in addition to the left and right
subtrees described before&#8212;<wbr></wbr>a "middle" subtree (the grey
edge) which assumes nothing about its node&rsquo;s atom.</p><p>In other words, for an arbitrary lazy (type) BDD</p><blockquote class="SCentered"><p><img style="vertical-align: -5.0px; margin: -3px -3px -3px -3px;" src="pict_214.png" alt="image" width="201.109130859375" height="110.5"/></p></blockquote><p>we would interpret the meaning of <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_215.png" alt="image" width="17.6748046875" height="27.0"/> (written&#12314;<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_216.png" alt="image" width="17.6748046875" height="27.0"/>&#12315;)
as follows:</p><blockquote class="SCentered"><p><img style="vertical-align: -5.419921875px; margin: -3px -3px -3px -3px;" src="pict_217.png" alt="image" width="440.4033203125" height="32.796875"/></p></blockquote><p>where <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_218.png" alt="image" width="17.6748046875" height="27.0"/> is interpreted as <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_219.png" alt="image" width="39.0732421875" height="33.32080078125"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_220.png" alt="image" width="17.6748046875" height="27.0"/> as
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_221.png" alt="image" width="61.1220703125" height="33.32080078125"/>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_222.png" alt="image" width="292.97021484375" height="256.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abdd-rep-grammar))" x-target-lift="Figure"></a>Figure&nbsp;16: </span>lazy function/product type BDDs</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3abdd-rep-grammar%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">16</span></a> describes in detail our
representation for the DNF function/product portions of a type
as lazy BDDs. Note that</p><ul><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_223.png" alt="image" width="17.6748046875" height="27.0"/> describes a lazy BDD of either
functions or products and is useful for describing functions
that are parametric w.r.t. which kind of atom they
contain;</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_224.png" alt="image" width="17.6748046875" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_225.png" alt="image" width="17.6748046875" height="27.0"/> are the leaves in our BDDs,
interpreted as <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_226.png" alt="image" width="39.0732421875" height="33.32080078125"/> and <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_227.png" alt="image" width="61.1220703125" height="33.32080078125"/> respectively;</p></li><li><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_228.png" alt="image" width="17.6748046875" height="27.0"/> describes a BDD node: a 4-tuple with an atom
and three sub-trees (whose meaning are described earlier in
this section);</p></li><li><p>an atom (<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_229.png" alt="image" width="16.5" height="27.0"/>) is either a product or a function
type&#8212;<wbr></wbr>a given BDD will only contain atoms of one kind or
the other; and</p></li><li><p><img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_230.png" alt="image" width="19.7607421875" height="34.5"/> and <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_231.png" alt="image" width="25.0166015625" height="34.5"/> simply allow us to be more
specific and describe what kind of atoms a particular <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_232.png" alt="image" width="17.6748046875" height="27.0"/>
contains.</p></li></ul><p>Although not explicit in the grammar, these trees are
constructed using an ordering on atoms that we leave up to
the reader to implement (note that this implies types, BDDs,
etc must all also have an ordering defined since these data
structures are mutually dependent). A simple lexicographic
ordering would work... a fast (possibly non-deterministic?)
hash code-based ordering should also work... the choice is
yours. The ordering&#8212;<wbr></wbr>written <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_233.png" alt="image" width="69.27978515625" height="27.0"/> and
the like&#8212;<wbr></wbr>will be called upon frequently in function
definitions for BDDs in the next section. The ordering
allows us to have consistent representations for BDDs with
similar elements.</p><p>To make some definitions more clear, "accessor functions"
which extract the various fields of a node are defined in
<a href="#%28counter._%28figure._fig~3anode-accessors%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">17</span></a>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_234.png" alt="image" width="209.62939453125" height="332.109375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3anode-accessors))" x-target-lift="Figure"></a>Figure&nbsp;17: </span>accessors for node fields</span></p></blockquote><p>Finally, we use a "smart constructor"&#8212;<wbr></wbr>defined in
<a href="#%28counter._%28figure._fig~3anode-smart-constructor%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">18</span></a>&#8212;<wbr></wbr>to perform some
obvious simplifications when constructing a BDD node. We use
an implicit syntax for the smart constructor (i.e. it looks
identical to constructing a normal node), so whenever we
construct a node (except of course on the right-hand side of
the definition in <a href="#%28counter._%28figure._fig~3anode-smart-constructor%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">18</span></a>)
we are using the smart constructor.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_235.png" alt="image" width="278.91943359375" height="99.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3anode-smart-constructor))" x-target-lift="Figure"></a>Figure&nbsp;18: </span>simplifying constructor for BDD nodes</span></p></blockquote><h5>3.3.4<tt>&nbsp;</tt><a name="(part._.Lazy_.B.D.D_.Operations)"></a>Lazy BDD Operations</h5><p>The operations on lazy BDDs can be understood by again
considering how we logically interpret a BDD:</p><blockquote class="SCentered"><p><img style="vertical-align: -5.419921875px; margin: -3px -3px -3px -3px;" src="pict_236.png" alt="image" width="547.04833984375" height="98.822265625"/></p></blockquote><p>Also, recall that BDD binary operations will only ever be
used on two BDDs with atoms of the same kind.</p><p><a href="#%28counter._%28figure._fig~3abdd-or%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">19</span></a> describes BDD union, i.e. logical
"or".</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_237.png" alt="image" width="559.43408203125" height="333.08203125"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abdd-or))" x-target-lift="Figure"></a>Figure&nbsp;19: </span>BDD union</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3abdd-and%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">20</span></a> describes BDD intersection, i.e.
logical "and".</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_238.png" alt="image" width="477.35302734375" height="410.109375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abdd-and))" x-target-lift="Figure"></a>Figure&nbsp;20: </span>BDD intersection</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3abdd-diff%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">21</span></a> describes BDD difference.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_239.png" alt="image" width="566.48876953125" height="302.068359375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abdd-diff))" x-target-lift="Figure"></a>Figure&nbsp;21: </span>BDD difference</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3abdd-not%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">22</span></a> describes BDD complement, i.e.
logical "not".</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_240.png" alt="image" width="450.79248046875" height="171.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3abdd-not))" x-target-lift="Figure"></a>Figure&nbsp;22: </span>BDD complement</span></p></blockquote><h4>3.4<tt>&nbsp;</tt><a name="(part._.Parsing_and_.Example_.Types)"></a>Parsing and Example Types</h4><p><a href="#%28counter._%28figure._fig~3aparse-type%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">23</span></a> defines a function that
converts the user-friendly types shown in
<a href="#%28counter._%28figure._fig~3atypes%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">5</span></a> into the internal representation we
have just finished describing:</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_241.png" alt="image" width="440.25" height="400.177734375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aparse-type))" x-target-lift="Figure"></a>Figure&nbsp;23: </span>type parsing function</span></p></blockquote><p>Here are a few simple examples of what types look like once
parsed:</p><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_242.png" alt="image" width="299.080078125" height="34.013671875"/></p><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_243.png" alt="image" width="405.984375" height="34.013671875"/></p><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_244.png" alt="image" width="582.45263671875" height="69.52734375"/></p><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_245.png" alt="image" width="587.115234375" height="69.52734375"/></p><h3>4<tt>&nbsp;</tt><a name="(part._.Implementing_.Semantic_.Subtyping)"></a>Implementing Semantic Subtyping</h3><p>Because we are working with set-theoretic types, we are free
to define subtyping purely in terms of type inhabitation
(see <a href="#%28counter._%28figure._fig~3asubtype-is-emptiness%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">7</span></a>), which is
precisely what we do (<a href="#%28counter._%28figure._fig~3asubtyping%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">24</span></a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_246.png" alt="image" width="207.18017578125" height="58.013671875"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3asubtyping))" x-target-lift="Figure"></a>Figure&nbsp;24: </span>(semantic) subtyping, defined in terms of type emptiness</span></p></blockquote><p>In the remainder of this section we examine how to decide
type inhabitation using the data structures introduced
in <a href="#%28part._sec~3arep%29" data-pltdoc="x">Set-theoretic Type Representation</a>.</p><h4>4.1<tt>&nbsp;</tt><a name="(part._.Deciding_.Type_.Inhabitation)"></a>Deciding Type Inhabitation</h4><p>A DNF type is uninhabited exactly when <span class="emph">each clause in
the overall disjunction is uninhabited</span>. With our DNF types
partitioned into base, product, and function segments (see
<a href="#%28counter._%28figure._fig~3atype-canonical-form%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a>):</p><blockquote class="SCentered"><p><img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_247.png" alt="image" width="408.412109375" height="33.32080078125"/></p></blockquote><p>we simply need ways to check if the base component
(<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_248.png" alt="image" width="20.8251953125" height="27.0"/>), product component (<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_249.png" alt="image" width="26.4658203125" height="27.0"/>), and function
component (<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_250.png" alt="image" width="29.1298828125" height="27.0"/>) each are empty.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_251.png" alt="image" width="458.1826171875" height="127.001953125"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aempty-type))" x-target-lift="Figure"></a>Figure&nbsp;25: </span>type emptiness predicate</span></p></blockquote><p>As <a href="#%28counter._%28figure._fig~3aempty-type%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">25</span></a> suggests, the
representation of the base type portion is simple enough
that we can pattern match on it directly to check if it is
empty (recall that <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_252.png" alt="image" width="67.1689453125" height="34.013671875"/> is the bottom/empty
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_253.png" alt="image" width="17.71728515625" height="27.0"/>).</p><p>For deciding if the product and function components&#8212;<wbr></wbr>which
are represented with lazy BDDs (see previous discussion in
<a href="#%28part._sec~3atypes-as-lazy-bdds%29" data-pltdoc="x">Types as Lazy BDDs!</a>)&#8212;<wbr></wbr>are empty, we rely on
helper functions <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_254.png" alt="image" width="67.4208984375" height="34.5"/> and <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_255.png" alt="image" width="67.4208984375" height="34.5"/> which are
defined in <a href="#%28part._sec~3aprod-inhabitation%29" data-pltdoc="x">Product Type Inhabitation</a> and
<a href="#%28part._sec~3aarrow-inhabitation%29" data-pltdoc="x">Function Type Inhabitation</a> respectively.</p><p>In these sections, we will use non-terminals <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_256.png" alt="image" width="20.2998046875" height="27.0"/> and
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_257.png" alt="image" width="21.75" height="27.0"/> to represent a collection of atoms
(see <a href="#%28counter._%28figure._fig~3aatom-sets%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">26</span></a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_258.png" alt="image" width="176.59423828125" height="94.0"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aatom-sets))" x-target-lift="Figure"></a>Figure&nbsp;26: </span>sets of atoms</span></p></blockquote><h5>4.1.1<tt>&nbsp;</tt><a name="(part._sec~3aprod-inhabitation)"></a>Product Type Inhabitation</h5><p>To decide if the product portion of a type is uninhabited,
we recall (from <a href="#%28part._sec~3apartitioning-types%29" data-pltdoc="x">Partitioning Types</a>) that it
is a union of conjunctive clauses, each of which can be
described with a pair of two sets (P,N), where P contains
the positive product types and N the negated product types:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_259.png" alt="image" width="489.74072265625" height="106.4593505859375"/></p></blockquote><p>For <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_260.png" alt="image" width="26.4658203125" height="27.0"/> to be uninhabited, <span class="emph">each</span> such clause
must be uninhabited. Checking that a given clause (P,N) is
uninhabited occurs in two steps:</p><ol><li><p>accumulate the positive type information in P into a
single product <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_261.png" alt="image" width="64.82666015625" height="27.0"/> (i.e. fold over the products
in P, accumulating their pairwise intersection in a single
product),</p></li><li><p>check that for each N&#8242; &#8838; N the following holds:</p></li></ol><blockquote class="SCentered"><p><img style="vertical-align: -4.1802978515625px; margin: -3px -3px -3px -3px;" src="pict_262.png" alt="image" width="427.102294921875" height="84.0"/></p></blockquote><p>The first step is justified because pairs are covariant in
their fields, i.e. if something is a <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_263.png" alt="image" width="70.53955078125" height="27.0"/>
<span class="emph">and</span> a <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_264.png" alt="image" width="73.43701171875" height="27.0"/> then it is also a
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_265.png" alt="image" width="196.26708984375" height="27.0"/>.</p><p>The second step is more complicated. To understand, let us
first note that if we know something is a product of some
sort and also that it is of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_266.png" alt="image" width="107.853515625" height="27.0"/>,
then either it is a product whose first field is
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_267.png" alt="image" width="44.10791015625" height="27.0"/> <span class="emph">or</span> it is a product whose second field
is <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_268.png" alt="image" width="44.10791015625" height="27.0"/> (i.e. logically we are applying DeMorgan&rsquo;s
law). And for the clause to be uninhabited, it must be
uninhabited for both possibilities (again, intuitively an
"or" is false only when all its elements are false). So by
exploring each subset <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_269.png" alt="image" width="71.05859375" height="26.0"/> and verifying that either the
left-hand side of the product is empty with the negated
left-hand sides in N <span class="emph">or</span> the right-hand side is empty
for the negated right-hand sides in the complement (i.e. <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_270.png" alt="image" width="65.4990234375" height="26.0"/>), we are exploring all possible combinations of negated
first and second fields from N and ensuring each possible
combination is indeed uninhabited.</p><p>We describe an algorithm to perform these computations in
<a href="#%28counter._%28figure._fig~3aempty-prod%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">27</span></a>. The function <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_271.png" alt="image" width="67.4208984375" height="34.5"/>
walks over each path in the product BDD accumulating the
positive information in a product <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_272.png" alt="image" width="64.82666015625" height="27.0"/> and the
negative information in the set N. Then at each non-trivial
leaf in the BDD, we call the helper function <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_273.png" alt="image" width="22.54541015625" height="34.5"/>
which searches the space of possible negation combinations
ensuring that for each possibility the pair ends up being
uninhabited.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_274.png" alt="image" width="406.76953125" height="435.4365234375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aempty-prod))" x-target-lift="Figure"></a>Figure&nbsp;27: </span>functions for checking if a product BDD is uninhabited</span></p></blockquote><p>Note that <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_275.png" alt="image" width="22.54541015625" height="34.5"/> is designed with a "short-circuiting"
behavior, i.e. as we are exploring each possible combination
of negations, if a negated field we are considering would
negate the corresponding positive field (e.g.
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_276.png" alt="image" width="70.55859375" height="27.0"/>) then we can stop searching for
emptiness on that side, otherwise we subtract that negated
type from the corresponding field and we keep searching the
remaining possible negations checking for emptiness. If we
reach the base case when N is the empty set, then we have
failed to show the product is empty and we return false.
(Note that <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_277.png" alt="image" width="67.4208984375" height="34.5"/> checks for emptiness before calling
<img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_278.png" alt="image" width="22.54541015625" height="34.5"/>, otherwise we would need to check <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_279.png" alt="image" width="20.2734375" height="27.0"/> and
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_280.png" alt="image" width="20.2734375" height="27.0"/> for emptiness in the base case of <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_281.png" alt="image" width="22.54541015625" height="34.5"/>).</p><h5>4.1.2<tt>&nbsp;</tt><a name="(part._sec~3aarrow-inhabitation)"></a>Function Type Inhabitation</h5><p>Just like with products, to show that the function portion
of a type is uninhabited we show that each clause in the
DNF&#8212;<wbr></wbr></p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_282.png" alt="image" width="501.72998046875" height="106.4593505859375"/></p></blockquote><p>&#8212;<wbr></wbr>i.e. each pair (P,N) where P contains the positive
function types and N the negated function types of the clause,
represents an uninhabited function type. To do this, we
show that for each clause (P,N) there exists a
(<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_283.png" alt="image" width="69.2783203125" height="27.0"/>) <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_284.png" alt="image" width="40.9794921875" height="26.0"/> such that</p><blockquote class="SCentered"><p><img style="vertical-align: -4.1802978515625px; margin: -3px -3px -3px -3px;" src="pict_285.png" alt="image" width="184.486083984375" height="84.0"/></p></blockquote><p>(i.e. <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_286.png" alt="image" width="20.16796875" height="27.0"/> is in the domain of the function) and that
for each <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_287.png" alt="image" width="68.296875" height="26.0"/>,</p><blockquote class="SCentered"><p><img style="vertical-align: -4.1802978515625px; margin: -3px -3px -3px -3px;" src="pict_288.png" alt="image" width="431.0947265625" height="84.0"/></p></blockquote><p>Basically we are verifying that for each possible set of
arrows P&#8242; which <span class="emph">must</span> handle a value of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_289.png" alt="image" width="20.16796875" height="27.0"/>
(i.e. the left-hand check fails), those arrows must map the
value to <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_290.png" alt="image" width="20.16796875" height="27.0"/> (the right-hand check), which is a
contradiction since we know this function is <span class="emph">not</span> of
type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_291.png" alt="image" width="69.2783203125" height="27.0"/> and therefore this function type is
uninhabited.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_292.png" alt="image" width="364.974609375" height="495.4365234375"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aempty-arrow))" x-target-lift="Figure"></a>Figure&nbsp;28: </span>functions for checking if a function BDD is uninhabited</span></p></blockquote><p>We implement this algorithm with the function <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_293.png" alt="image" width="67.4208984375" height="34.5"/>
defined in <a href="#%28counter._%28figure._fig~3aempty-arrow%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">28</span></a>. It walks each
path in a function BDD accumulating the domain along the way
and collecting the negated function types in the variable
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_294.png" alt="image" width="21.75" height="27.0"/>. At the non-trivial leaves of the BDD, it calls
<img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_295.png" alt="image" width="22.54541015625" height="34.5"/> with each function type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_296.png" alt="image" width="69.2783203125" height="27.0"/> <img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_297.png" alt="image" width="40.9794921875" height="26.0"/>
until it finds a contradiction (i.e. an arrow that satisfies
the above described equation) or runs out of negated
function types.</p><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_298.png" alt="image" width="22.54541015625" height="34.5"/> is the function which explores each set of
arrows P&#8242; &#8838; P checking that one of the two clauses in the
above noted disjunction is true. Note that in the initial
call from <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_299.png" alt="image" width="67.4208984375" height="34.5"/> we negate the original <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_300.png" alt="image" width="20.16796875" height="27.0"/>: this
is because although we are interested in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_301.png" alt="image" width="70.55859375" height="27.0"/>,
the equivalent "contrapositive" statement
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_302.png" alt="image" width="98.572265625" height="27.0"/> is more convenient to
accumulatively check as we iterate through the function
types in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_303.png" alt="image" width="20.2998046875" height="27.0"/>.</p><p>In the base case of <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_304.png" alt="image" width="22.54541015625" height="34.5"/> when P has been exhausted,
the function checks that either the arrows not in P&#8242; could
have handled the value of (the <span class="emph">original</span>) type
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_305.png" alt="image" width="20.16796875" height="27.0"/> (i.e. is <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_306.png" alt="image" width="20.16796875" height="27.0"/> now empty), otherwise it checks
if the value we mapped the input to must be a subtype of
(the <span class="emph">original</span>) type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_307.png" alt="image" width="20.16796875" height="27.0"/> (i.e. is <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_308.png" alt="image" width="20.16796875" height="27.0"/> now
empty).</p><p>In the case where <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_309.png" alt="image" width="20.2998046875" height="27.0"/> has not been exhausted, we examine the
first arrow <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_310.png" alt="image" width="69.4892578125" height="27.0"/> in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_311.png" alt="image" width="20.2998046875" height="27.0"/> and check two cases:
one for when that arrow is not in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_312.png" alt="image" width="26.830078125" height="27.0"/> (i.e. when it is in
<img style="vertical-align: -3.8798828125px; margin: -3px -3px -3px -3px;" src="pict_313.png" alt="image" width="62.7373046875" height="26.0"/>) and one for when it is in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_314.png" alt="image" width="26.830078125" height="27.0"/>.</p><p>The first clause in the conjunction of the non-empty P case
is for when <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_315.png" alt="image" width="69.4892578125" height="27.0"/> is not in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_316.png" alt="image" width="26.830078125" height="27.0"/>. It first checks
if the set of arrows we&rsquo;re not considering (i.e. P \ P&#8242;)
would handle a value of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_317.png" alt="image" width="20.16796875" height="27.0"/> (i.e.
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_318.png" alt="image" width="70.55859375" height="27.0"/>), and if not it remembers that
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_319.png" alt="image" width="69.4892578125" height="27.0"/> is not in P&#8242; by subtracting <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_320.png" alt="image" width="20.2734375" height="27.0"/> from
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_321.png" alt="image" width="20.16796875" height="27.0"/> for the recursive call which keeps searching.</p><p>The second clause in the conjunction is for when
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_322.png" alt="image" width="69.4892578125" height="27.0"/> is in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_323.png" alt="image" width="26.830078125" height="27.0"/>. As we noted, instead of
checking <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_324.png" alt="image" width="70.55859375" height="27.0"/> (resembling the original
mathematical description above), it turns out to be more
convenient to check the contrapositive statement
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_325.png" alt="image" width="84.5654296875" height="27.0"/> (recall that <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_326.png" alt="image" width="20.16796875" height="27.0"/> was actually
negated originally when <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_327.png" alt="image" width="22.54541015625" height="34.5"/> was called). First we
check if having <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_328.png" alt="image" width="69.4892578125" height="27.0"/> in <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_329.png" alt="image" width="26.830078125" height="27.0"/> means we would
indeed map a value of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_330.png" alt="image" width="20.16796875" height="27.0"/> to a value of type
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_331.png" alt="image" width="20.16796875" height="27.0"/> (i.e. the <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_332.png" alt="image" width="84.5654296875" height="27.0"/> check). If so
we are done, otherwise we recur while remembering that
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_333.png" alt="image" width="69.4892578125" height="27.0"/> is in P&#8242; by adding <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_334.png" alt="image" width="20.2734375" height="27.0"/> to <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_335.png" alt="image" width="20.16796875" height="27.0"/>
(i.e. "subtracting" negated <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_336.png" alt="image" width="20.2734375" height="27.0"/> from the negated <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_337.png" alt="image" width="20.16796875" height="27.0"/>
we are accumulating by using intersection).</p><h3>5<tt>&nbsp;</tt><a name="(part._.Other_.Key_.Type-level_.Functions)"></a>Other Key Type-level Functions</h3><p>In addition to being able to decide type inhabitation, we
need to be able to semantically calculate types for the
following situations:</p><ol><li><p>projection from a product,</p></li><li><p>a function&rsquo;s domain, and</p></li><li><p>the result of function application.</p></li></ol><h4>5.1<tt>&nbsp;</tt><a name="(part._.Product_.Projection)"></a>Product Projection</h4><p>In a language with syntactic types, calculating the type of
the first or second projection of a pair simply involves
matching on the product type and extracting the first or
second field. In a language with semantic types, however, we
could be dealing with a complex pair type which uses
numerous set-theoretic constructors and we can no longer
simply pattern match to determine the types of its
projections. Instead, we must reason semantically about the
fields.</p><p>To begin, first note that if a type is a subtype of
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_338.png" alt="image" width="48.40869140625" height="33.32080078125"/> (i.e. it is indeed a pair), we can focus on
the product portion of the type:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_339.png" alt="image" width="489.74072265625" height="106.4593505859375"/></p></blockquote><p>Projecting the field <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_340.png" alt="image" width="11.83740234375" height="27.0"/> from <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_341.png" alt="image" width="26.4658203125" height="27.0"/> (where <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_342.png" alt="image" width="11.83740234375" height="27.0"/> &#8712;
{1,2}) involves unioning each positive type for field <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_343.png" alt="image" width="11.83740234375" height="27.0"/>
in the DNF intersected with each possible combination of
negations for that field:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_344.png" alt="image" width="473.130859375" height="130.95941162109375"/></p></blockquote><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>This calculation follows the same line of
reasoning involved with deciding product type inhabitation
(see <a href="#%28part._sec~3aprod-inhabitation%29" data-pltdoc="x">Product Type Inhabitation</a>), i.e. it considers
each logical clause in the DNF of the type and unions them.</p></blockquote></blockquote></blockquote><p>Actually that equation is sound but a little too coarse: it
only considers the type of field <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_345.png" alt="image" width="11.83740234375" height="27.0"/> and thus may include
some impossible cases where the <span class="emph">other</span> field would
have been <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_346.png" alt="image" width="61.1220703125" height="33.32080078125"/>. In other words, if <span style="font-style: italic">j</span> is an
index and <span style="font-style: italic">j &#8800; i</span> (i.e. it is the index of the other
field), then as we&rsquo;re calculating the projection of
<span style="font-style: italic">i</span>, we&rsquo;ll want to "skip" any cases <span style="font-style: italic">N&#8242;</span> where
the following is true:</p><blockquote class="SCentered"><p><img style="vertical-align: -4.1802978515625px; margin: -3px -3px -3px -3px;" src="pict_347.png" alt="image" width="404.68505859375" height="84.0"/></p></blockquote><p>i.e. cases where the other field <span style="font-style: italic">j</span> is uninhabited. If
we incorporate that subtlety, our inner loop will end up
containing a conditional statement:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.6189208984374996px; margin: -3px -3px -3px -3px;" src="pict_348.png" alt="image" width="660.9701660156251" height="231.71065063476564"/></p></blockquote><h5>5.1.1<tt>&nbsp;</tt><a name="(part._.Implementing_.Product_.Projection)"></a>Implementing Product Projection</h5><p>As was suggested by our use of index variables <span style="font-style: italic">i</span> and
<span style="font-style: italic">j</span> in the previous section&rsquo;s discussion, we implement
product projection as a single function indexed by some
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_349.png" alt="image" width="11.83740234375" height="27.0"/> <span style="font-style: italic">&#8712; </span>{<span style="font-style: italic"></span>1<span style="font-style: italic">,</span>2<span style="font-style: italic"></span>}<span style="font-style: italic"></span> and use <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_350.png" alt="image" width="72.146484375" height="34.013671875"/> (defined in
<a href="#%28counter._%28figure._fig~3aselect%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">29</span></a>) to return the appropriate type
in non-empty clauses.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_351.png" alt="image" width="203.38330078125" height="96.041015625"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aselect))" x-target-lift="Figure"></a>Figure&nbsp;29: </span>function for selecting a type during product projection</span></p></blockquote><p>Because projection can fail, we have the function
<img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_352.png" alt="image" width="56.396484375" height="34.5"/> as the "public interface" to projection.
<img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_353.png" alt="image" width="56.396484375" height="34.5"/> performs important preliminary checks
(i.e. is this type actually a product?) before extracting
the product portion of the type and passing it to the
"internal" function <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_354.png" alt="image" width="50.09765625" height="34.013671875"/> where the real work begins.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_355.png" alt="image" width="399.83349609375" height="685.341796875"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3aproject))" x-target-lift="Figure"></a>Figure&nbsp;30: </span>functions for projecting from a product type</span></p></blockquote><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_356.png" alt="image" width="50.09765625" height="34.013671875"/> walks the BDD, accumulating for each path (i.e.
each clause in the DNF) the positive type information for
each field in variables <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_357.png" alt="image" width="20.2734375" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_358.png" alt="image" width="20.2734375" height="27.0"/> respectively.
Along the way, if either <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_359.png" alt="image" width="20.2734375" height="27.0"/> or <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_360.png" alt="image" width="20.2734375" height="27.0"/> are empty we
can ignore that path. Otherwise at non-trivial leaves we
call the helper function <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_361.png" alt="image" width="28.7958984375" height="27.0"/> which traverses
the possible combinations of negations, calculating and
unioning the type of field <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_362.png" alt="image" width="11.83740234375" height="27.0"/> for each possibility.</p><h4>5.2<tt>&nbsp;</tt><a name="(part._.Function_.Domain)"></a>Function Domain</h4><p>Similar to product projection, deciding the domain of a
function in a language with set-theoretic types cannot be
done using simple pattern matching; we must reason about the
domain of a function type potentially constructed with
intersections and/or unions.</p><p>To do this, first note that for an intersection of arrows,
the domain is equivalent to the union of each of the domains
(i.e. the function can accept any value any of the various
arrows can collectively accept):</p><blockquote class="SCentered"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_363.png" alt="image" width="426.5078125" height="27.0"/></p></blockquote><p>Second, note that for a union of arrows, the domain is
equivalent to the intersection of each of the domains (i.e.
the function can only accept values that each of the arrows
can accept):</p><blockquote class="SCentered"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_364.png" alt="image" width="426.5078125" height="27.0"/></p></blockquote><p>With those two points in mind, we can deduce that the domain
of an <span class="emph">arbitrary</span> function type</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_365.png" alt="image" width="501.72998046875" height="106.4593505859375"/></p></blockquote><p>is the following intersection of unions:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_366.png" alt="image" width="164.112060546875" height="106.4593505859375"/></p></blockquote><h5>5.2.1<tt>&nbsp;</tt><a name="(part._.Implementing_.Function_.Domain)"></a>Implementing Function Domain</h5><p>We perform those domain calculations with the functions
defined in <a href="#%28counter._%28figure._fig~3adomain%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">31</span></a>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_367.png" alt="image" width="404.43603515625" height="405.6767578125"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3adomain))" x-target-lift="Figure"></a>Figure&nbsp;31: </span>domain calculation for function types</span></p></blockquote><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_368.png" alt="image" width="45.3720703125" height="34.5"/> first checks if the type is indeed a
function (i.e. is it a subtype of <img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_369.png" alt="image" width="29.3671875" height="34.5"/>), if so it
then calls <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_370.png" alt="image" width="39.0732421875" height="34.013671875"/> with the function portion of the type
(<img style="vertical-align: -5.69091796875px; margin: -3px -3px -3px -3px;" src="pict_371.png" alt="image" width="25.0166015625" height="34.5"/>) to begin traversing the BDD calculating the
intersection of the union of the respective domains.</p><h4>5.3<tt>&nbsp;</tt><a name="(part._.Function_.Application)"></a>Function Application</h4><p>When applying an arbitrary function to a value, we
must be able to determine the type of the result. If the
application is simple, e.g. a function of type
<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_372.png" alt="image" width="107.0888671875" height="33.32080078125"/> applied to an argument of type <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_373.png" alt="image" width="39.0732421875" height="33.32080078125"/>,
calculating the result is trivial (<img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_374.png" alt="image" width="39.0732421875" height="33.32080078125"/>). However, when
we are dealing with an arbitrarily complicated function type
which could contain set-theoretic connectives, deciding the
return type is a little more complicated. As we did in the
previous section, let us again reason separately about how
we might apply intersections and unions of function types to
guide our intuition.</p><p>In order to apply a union of function types, the argument
type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_375.png" alt="image" width="18.57861328125" height="27.0"/> of course would have to be in the domain of each
function (see the discussion in the previous section). The
result type of the application would then be the union of
the ranges:</p><blockquote class="SCentered"><p><img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_376.png" alt="image" width="526.20166015625" height="27.0"/></p></blockquote><p>This corresponds to the logical observation that if we know
P and that <span class="emph">either</span> P implies Q <span class="emph">or</span> P implies R,
then we can conclude that either Q or R holds.</p><p>When applying an intersection of function types, the result
type is the <span class="emph">combination</span> (i.e. intersection) of each
applicable arrow&rsquo;s range. This more or less corresponds to
the logical observation that if we know P and that <span class="emph">both</span> P implies Q <span class="emph">and</span> P implies R, then we can
conclude that Q <span class="emph">and</span> R hold.</p><p>Combining these lines of reasoning we can deduce that when
considering a function type</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_377.png" alt="image" width="501.72998046875" height="106.4593505859375"/></p></blockquote><p>being applied to an argument of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_378.png" alt="image" width="18.57861328125" height="27.0"/>, we first verify
that <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_379.png" alt="image" width="18.57861328125" height="27.0"/> is in the domain of <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_380.png" alt="image" width="29.1298828125" height="27.0"/> (i.e. using
<img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_381.png" alt="image" width="45.3720703125" height="34.5"/>) and then calculate the result type of the
application as follows:</p><blockquote class="SCentered"><p><img style="vertical-align: -2.909912109375px; margin: -3px -3px -3px -3px;" src="pict_382.png" alt="image" width="505.01318359375" height="253.97711181640625"/></p></blockquote><p>Basically, we traverse each clause in the DNF of the
function type (i.e. each pair (P,N)) unioning the results.
In each clause (P,N), we consider each possible set of
arrows P&#8242; in P and if that set would necessarily have to
handle a value of type <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_383.png" alt="image" width="18.57861328125" height="27.0"/>. For those sets P&#8242; that would
necessarily handle the input, we intersect their arrow&rsquo;s
result types (otherwise we ignore it by returning <img style="vertical-align: -6.6357421875px; margin: -3px -3px -3px -3px;" src="pict_384.png" alt="image" width="61.1220703125" height="33.32080078125"/>
for that clause). This reasoning resembles that which was
required to decide function type inhabitation (see
<a href="#%28part._sec~3aarrow-inhabitation%29" data-pltdoc="x">Function Type Inhabitation</a>), i.e. both are
considering which combinations of arrows necessarily need to
be considered to perform the relevant calculation.</p><h5>5.3.1<tt>&nbsp;</tt><a name="(part._.Implementing_.Function_.Application)"></a>Implementing Function Application</h5><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_385.png" alt="image" width="504.9140625" height="522.0498046875"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3afunapp))" x-target-lift="Figure"></a>Figure&nbsp;32: </span>function application result type calculations</span></p></blockquote><p><a href="#%28counter._%28figure._fig~3afunapp%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">32</span></a> describes the functions which
calculate the result type for function application.
<img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_386.png" alt="image" width="67.4208984375" height="34.5"/> first ensures that the alleged function
type is indeed a function with the appropriate domain before
calling <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_387.png" alt="image" width="61.1220703125" height="34.013671875"/> to calculate the result type of the
application. <img style="vertical-align: -6.67822265625px; margin: -3px -3px -3px -3px;" src="pict_388.png" alt="image" width="61.1220703125" height="34.013671875"/> then traverses the BDD combining
recursive results via union. As it traverses down a BDD
node&rsquo;s left edge (i.e. when a function type <span class="emph">is</span> a
member of a set P) it makes two recursive calls: one for
when that arrow <span class="emph">is</span> in P&#8242; (where we intersect the
arrow&rsquo;s range <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_389.png" alt="image" width="20.2734375" height="27.0"/> with the result type accumulator
<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_390.png" alt="image" width="14.16796875" height="27.0"/>) and one for when it <span class="emph">is not</span> in P&#8242; (where we
subtract <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_391.png" alt="image" width="20.2734375" height="27.0"/> from the argument type parameter <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_392.png" alt="image" width="20.16796875" height="27.0"/>
to track if the arrows in P \ P&#8242; can handle the argument
type). At non-trivial leaves where <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_393.png" alt="image" width="20.16796875" height="27.0"/> is not empty
(i.e. when we&rsquo;re considering a set of arrows P&#8242; which
necessarily <span class="emph">would</span> need to handle the argument) we
return the accumulated range type (<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_394.png" alt="image" width="14.16796875" height="27.0"/>) for that set of
arrows. Note that we can "short-circuit" the calculation
when either of the accumulators (<img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_395.png" alt="image" width="14.16796875" height="27.0"/> and <img style="vertical-align: -4.07373046875px; margin: -3px -3px -3px -3px;" src="pict_396.png" alt="image" width="20.16796875" height="27.0"/>)
are empty, which is important to keeping the complexity
of this calculation reasonable.</p><h3>6<tt>&nbsp;</tt><a name="(part._.Strategies_for_.Testing)"></a>Strategies for Testing</h3><p>For testing an implementation of the data structures and
algorithms described in this tutorial there are some
convenient properties we can leverage:</p><ul><li><p>(1) any type generated by the grammar of types is a
valid type;</p></li><li><p>(2) since these types logically correspond to sets,
we can create tests based on well-known set properties and
ensure our types behave equivalently; and</p></li><li><p>(3) we have "naive", inefficient mathematical
descriptions of many of the algorithms in addition to more
efficient algorithms which purport to perform the same
calculation.</p></li></ul><p>With these properties in mind, in addition to writing simple
"unit tests" that are written entirely by hand we can use a
tool such as QuickCheck<span class="Autobibref">&nbsp;(<a href="#%28autobib._.Koen._.Claessen._and._.John._.Hughes.Quick.Check~3a._a._lightweight._tool._for._random._testing._of._.Haskell._programs.In._.Proc..._.The._5th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming._%28.I.C.F.P%292000%29" class="AutobibLink" data-pltdoc="x">Claessen and Hughes</a> <a href="#%28autobib._.Koen._.Claessen._and._.John._.Hughes.Quick.Check~3a._a._lightweight._tool._for._random._testing._of._.Haskell._programs.In._.Proc..._.The._5th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming._%28.I.C.F.P%292000%29" class="AutobibLink" data-pltdoc="x">2000</a>)</span> or
<span class="stt">redex-check</span><span class="Autobibref">&nbsp;(<a href="#%28autobib._.Burke._.Fetscher%2C._.Koen._.Claessen%2C._.Micha~c5~82._.Pa~c5~82ka%2C._.John._.Hughes%2C._and._.Robert._.Bruce._.Findler.Making._.Random._.Judgments~3a._.Automatically._.Generating._.Well-.Typed._.Terms._from._the._.Definition._of._a._.Type-.System.In._.Proc..._.E.S.O.P2015%29" class="AutobibLink" data-pltdoc="x">Fetscher et al<span class="Sendabbrev">.</span></a> <a href="#%28autobib._.Burke._.Fetscher%2C._.Koen._.Claessen%2C._.Micha~c5~82._.Pa~c5~82ka%2C._.John._.Hughes%2C._and._.Robert._.Bruce._.Findler.Making._.Random._.Judgments~3a._.Automatically._.Generating._.Well-.Typed._.Terms._from._the._.Definition._of._a._.Type-.System.In._.Proc..._.E.S.O.P2015%29" class="AutobibLink" data-pltdoc="x">2015</a>)</span> to generate
random types and verify our implementation respects
well-known set properties. Additionally, we can write two
implementations of algorithms which have both a naive and
efficient description and feed them random input while
checking that their outputs are always equivalent.</p><p>The model we used to generate the pseudo code in this
tutorial uses these testing strategies. This approach helped
us discover several subtle bugs in our implementation at
various points that simpler hand-written unit tests had not
yet exposed.</p><h3><a name="(part._doc-bibliography)"></a>Bibliography</h3><p><table cellspacing="0" cellpadding="0" class="AutoBibliography"><tr><td><p><a name="(autobib._.Giuseppe._.Castagna.Covariance._and._.Contravariance~3a._a._fresh._look._at._an._old._issue._(a._primer._in._advanced._type._systems._for._learning._functional._programmers)2013.Unpublished._manuscript,._periodically._updated..)"></a><span class="Autobibentry">Giuseppe Castagna. Covariance and Contravariance: a fresh look at an old issue (a primer in advanced type systems for learning functional programmers). 2013. Unpublished manuscript, periodically updated.</span></p></td></tr><tr><td><p><a name="(autobib._.Koen._.Claessen._and._.John._.Hughes.Quick.Check~3a._a._lightweight._tool._for._random._testing._of._.Haskell._programs.In._.Proc..._.The._5th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming._(.I.C.F.P)2000)"></a><span class="Autobibentry">Koen Claessen and John Hughes. QuickCheck: a lightweight tool for random testing of Haskell programs. In <span style="font-style: italic">Proc. The 5th ACM SIGPLAN International Conference on Functional Programming (ICFP)</span>, 2000.</span></p></td></tr><tr><td><p><a name="(autobib._.Burke._.Fetscher,._.Koen._.Claessen,._.Micha~c5~82._.Pa~c5~82ka,._.John._.Hughes,._and._.Robert._.Bruce._.Findler.Making._.Random._.Judgments~3a._.Automatically._.Generating._.Well-.Typed._.Terms._from._the._.Definition._of._a._.Type-.System.In._.Proc..._.E.S.O.P2015)"></a><span class="Autobibentry">Burke Fetscher, Koen Claessen, Micha&#322; Pa&#322;ka, John Hughes, and Robert Bruce Findler. Making Random Judgments: Automatically Generating Well-Typed Terms from the Definition of a Type-System. In <span style="font-style: italic">Proc. ESOP</span>, 2015.</span></p></td></tr><tr><td><p><a name="(autobib._.Alain._.Frisch,._.Giuseppe._.Castagna,._and._.V~c3~a9ronique._.Benzaken.Semantic._subtyping~3a._.Dealing._set-theoretically._with._function,._union,._intersection,._and._negation._types...Journal._of._the._.A.C.M._55(19)2008)"></a><span class="Autobibentry">Alain Frisch, Giuseppe Castagna, and V&#233;ronique Benzaken. Semantic subtyping: Dealing set-theoretically with function, union, intersection, and negation types. <span style="font-style: italic">Journal of the ACM</span> 55(19), 2008.</span></p></td></tr><tr><td><p><a name="(autobib._.Casey._.Klein,._.John._.Clements,._.Christos._.Dimoulas,._.Carl._.Eastlund,._.Matthias._.Felleisen,._.Matthew._.Flatt,._.Jay._.A..._.Mc.Carthy,._.Jon._.Rafkind,._.Sam._.Tobin-.Hochstadt,._and._.Robert._.Bruce._.Findler.Run._.Your._.Research~3a._.On._the._.Effectiveness._of._.Lightweight._.Mechanization.In._.Proc..._.The._39th._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages._(.P.O.P.L)2012)"></a><span class="Autobibentry">Casey Klein, John Clements, Christos Dimoulas, Carl Eastlund, Matthias Felleisen, Matthew Flatt, Jay A. McCarthy, Jon Rafkind, Sam Tobin-Hochstadt, and Robert Bruce Findler. Run Your Research: On the Effectiveness of Lightweight Mechanization. In <span style="font-style: italic">Proc. The 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL)</span>, 2012.</span></p></td></tr></table></p></div></div><div id="contextindicator">&nbsp;</div></body></html>